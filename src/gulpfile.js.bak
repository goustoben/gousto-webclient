/**
 * @file gulpfile.js
 * @fileOverview gulpfile.
 * @author <a href="mailto:info@gousto.co.uk">Gousto</a>
 * @version 1.0
 * @copyright Gousto 2015
 */

"use strict";

try {
	var gulp = require('gulp');
	var rimraf = require('rimraf');
	var es = require('event-stream');
	var runSequence = require('run-sequence');
	var gutil = require('gulp-util');
	var psi = require('psi');
	var path = require('path');
	var fs = require('fs');
	var merge = require('merge-stream');
	var livereload = require('gulp-livereload');
	var merge = require('merge-stream');
	var sass = require('node-sass');
	var plugins = require("gulp-load-plugins")({
		pattern: ['gulp-*', 'gulp.*'],
		replaceString: /\bgulp[\-.]/
	});
	var RevAll = require('gulp-rev-all');
}
catch (e) {
	console.log('There was a fatal error requiring npm modules. Exiting after stacktrace:');
	console.log(e);
	process.exit(1);
}

var siteUrl = 'https://www.gousto.co.uk/this-weeks-recipes';
var liveReloadOptions = {
	port: '35729',
	host: 'frontend.gousto.local',
	start: true
};
var devUrl = "/img";
var cloudfrontUrl = 'https://d39tu2l2az53k2.cloudfront.net';
var awsBucket = "gousto2-production-assets";
var productServiceDomain = 'http://products.gousto.local';

var plugins = require("gulp-load-plugins")({
	pattern: ['gulp-*', 'gulp.*'],
	replaceString: /\bgulp[\-.]/
});

// Allows gulp --dev to be run for a more verbose output
var isProduction = false;
var sassStyle = 'compressed';
var sourceMap = false;

if (gutil.env.prod === true) {
	sassStyle = 'expanded';
	sourceMap = true;
	isProduction = true;
}

if (typeof gutil.env.bucket !== 'undefined') {
	awsBucket = gutil.env.bucket;
}

if (typeof gutil.env.cfurl !== 'undefined') {
	cloudfrontUrl = gutil.env.cfurl;
}

if (typeof gutil.env.psdomain !== 'undefined') {
	productServiceDomain = gutil.env.psdomain;
}

var gzip_options = {
	threshold: '1kb',
	gzipOptions: {
		level: 9
	}
};
var awsOptions = {
	gzippedOnly: false
}
var basePaths = {
	src: 'app/assets/',
	dest: 'public/'
};

var paths = {
	images: {
		src: basePaths.src + 'images/',
		dest: basePaths.dest + 'img/'
	},
	scripts: {
		orderPath: './app/assets/javascripts/application.json',
		order: require('./app/assets/javascripts/application.json'),
		src: basePaths.src + 'javascripts/',
		dest: basePaths.dest + 'js/'
	},
	styles: {
		orderPath: './app/assets/stylesheets/application.json',
		order: require('./app/assets/stylesheets/application.json'),
		src: basePaths.src + 'stylesheets/',
		dest: basePaths.dest + 'css/'
	},
	fonts: {
		src: basePaths.src + 'fonts/',
		dest: basePaths.dest + 'fonts/'
	}
};

var manifestFilename = 'public/rev-manifest.json';

var appFiles = {
	styles: paths.styles.src + '**/*.scss',
	scripts: paths.scripts.src + '**/*.js',
	images: paths.images.src + '**/*.{jpg,png,gif,ico}',
	fonts: paths.fonts.src + '**/*.{eot,svg,ttf,woff,woff2,otf}'
};

var vendorFiles = {
	styles: '',
	scripts: ''
};

function getFolders(dir) {
	return fs.readdirSync(dir)
		.filter(function(file) {
			return fs.statSync(path.join(dir, file)).isDirectory();
		});
}


gulp.task('gzipscripts', ['scripts'], function() {
	var src = [paths.scripts.dest + "/*.js"];
	return gulp.src(src)
		.pipe(plugins.rename(function (path) {
			path.dirname = '/gz/' + path.dirname;
		}))
		.pipe(gulp.dest(paths.scripts.dest));
});

gulp.task('gzipfonts', ['fonts'], function() {
	var src = [paths.fonts.dest + "/*"];
	return gulp.src(src)
		.pipe(plugins.rename(function (path) {
			path.dirname = '/gz/' + path.dirname;
		}))
		.pipe(gulp.dest(paths.fonts.dest));
});

gulp.task('syncSourceMaps', ['gzipscripts'], function(){
	if(isProduction){
		gutil.noop();
	} else {
		var src = paths.scripts.dest + '**/*.js.map';
		return gulp.src(src)
		.pipe(gulp.dest(paths.scripts.dest + '/gz/'));
	}
});

//javascript minification and concatenation
gulp.task('scripts', function() {
	var src = paths.scripts.order;
	var revAll = new RevAll();

	return gulp.src(src)
		.pipe(isProduction ? gutil.noop() : plugins.sourcemaps.init())
		.pipe(isProduction ? plugins.uglify() : gutil.noop())
		.pipe(plugins.concat('application.js'))

	.pipe(revAll.revision())
	.pipe(isProduction ? gutil.noop() : plugins.sourcemaps.write('./'))
	.pipe(gulp.dest(paths.scripts.dest)) // write rev'd assets to build dir
		.pipe(plugins.rev.manifest(manifestFilename, {
			base: 'public/',
			merge: true
		}))

		.pipe(gulp.dest(basePaths.dest)); // write manifest to public dir

});

gulp.task('aws', function() {
	var awspublish = require('gulp-awspublish');

	// create a new publisher
	var publisher = awspublish.create({
		params: { Bucket: awsBucket }
	});

	// define custom headers
	var headers = {
		'Cache-Control': 'max-age=315360000, no-transform, public'
			// ...
	};
	var gzipSrc = gulp.src([paths.scripts.dest + "*", paths.styles.dest + "*", paths.fonts.dest + "**/*"])
		// gzip, Set Content-Encoding headers
		.pipe(plugins.rename(function (path) {
			path.dirname = '/gz/' + path.dirname;
		}))
		.pipe(awspublish.gzip())
	.pipe(gulp.dest(basePaths.dest));
	var plainSrc = gulp.src([paths.images.dest + '**/*']);

	return merge(gzipSrc, plainSrc)


	// publisher will add Content-Length, Content-Type and headers specified above
	// If not specified it will set x-amz-acl to public-read by default
	.pipe(publisher.publish(headers))

	// create a cache file to speed up consecutive uploads
	.pipe(publisher.cache())

	// print upload updates to console
	.pipe(awspublish.reporter());

});
gulp.task('awsFonts', function() {
	var awspublish = require('gulp-awspublish');

	// create a new publisher
	var publisher = awspublish.create({
		params: { Bucket: awsBucket }
	});

	// define custom headers
	var headers = {
		'Cache-Control': 'max-age=315360000, no-transform, public'
			// ...
	};
	var gzipSrc = gulp.src([paths.fonts.dest + "**/*"])
		// gzip, Set Content-Encoding headers
		.pipe(plugins.rename(function (path) {
			path.dirname = '/fonts/' + path.dirname;
		}))
	.pipe(awspublish.gzip())
	.pipe(gulp.dest(basePaths.dest));

	return gzipSrc


	// publisher will add Content-Length, Content-Type and headers specified above
	// If not specified it will set x-amz-acl to public-read by default
	.pipe(publisher.publish(headers))

	// create a cache file to speed up consecutive uploads
	.pipe(publisher.cache())

	// print upload updates to console
	.pipe(awspublish.reporter());

});
gulp.task('awsold', function() {
	var aws = require('./aws.json');

	var options = {
		delay: 200,
		headers: {
			'Cache-Control': 'max-age=315360000, no-transform, public'
		}
	};

	gulp.src([paths.scripts.dest + "*", paths.styles.dest + "*", paths.images.dest + "**/*"])
		.pipe(plugins.s3(aws, awsOptions))
		.pipe(plugins.size());
});
//javascript lint
gulp.task('eslint', function() {
	return gulp.src(appFiles.scripts)
		.pipe(plugins.eslint())
		.pipe(plugins.eslint.format())
		// .pipe(plugins.eslint.failOnError());
});

//lossless image compression
gulp.task('smushit', function() {
	return gulp.src(appFiles.images)
		.pipe(plugins.smushit())
		.pipe(gulp.dest(paths.images.dest));
});

gulp.task('images', function() {
	/* don't add revision hash to images, we want them to be static,
	but still added to the manifest */
	var revAll = new RevAll({
		dontRenameFile: [/(.* )?/]
	});
	return gulp.src(appFiles.images)
		// .pipe(plugins.smushit())
		.pipe(revAll.revision({
			quiet: (!isProduction)
		}))
		.pipe(isProduction ? plugins.rename({
			suffix: ''
		}) : gutil.noop())
		.pipe(gulp.dest(paths.images.dest)) // write rev'd assets to build dir
		.pipe(plugins.rev.manifest(manifestFilename, {
			base: 'public/',
			merge: true
		}))

	.pipe(gulp.dest(basePaths.dest)); // write manifest to public dir

});

gulp.task('fonts', function() {
	/* don't add revision hash to fonts, we want them to be static,
	but still added to the manifest */
	var revAll = new RevAll({
		dontRenameFile: [/(.* )?/]
	});
	return gulp.src(appFiles.fonts)

		.pipe(revAll.revision({}))
		.pipe(gulp.dest(paths.fonts.dest)) // write rev'd assets to build dir
		.pipe(plugins.rev.manifest(manifestFilename, {
			base: 'public/',
			merge: true
		}))
		.pipe(gulp.dest(basePaths.dest));
});

gulp.task('gzipstyles', ['styles'], function() {
	var src = [paths.styles.dest + "/*.css"];
	return gulp.src(src)
		.pipe(plugins.rename(function (path) {
			path.dirname = '/gz/' + path.dirname;
		}))
		.pipe(gulp.dest(paths.styles.dest));
});
gulp.task('styles', function() {
	var src = paths.styles.order;
	var revAll = new RevAll();
	return gulp.src(src)

		.pipe(plugins.plumber({
			errorHandler: function(error) {
				console.log(error);
				plugins.notify.onError("Error: <%= error.message %>");
			}
		}))

		.pipe(plugins.sass({
			outputStyle: sassStyle,
			functions: {
				'image-url($img)': function(img) {
					return new sass.types.String('url("' + (isProduction ? cloudfrontUrl : devUrl) + '/' + img.getValue() + '")');
				}
			}
		})).on("error", plugins.notify.onError(function(error) {
			return "Error: " + error.message;
		}))

		.pipe(isProduction ? plugins.cssmin() : gutil.noop())

		.pipe(plugins.concat('application.css'))


		.pipe(revAll.revision({}))

		.pipe(gulp.dest(paths.styles.dest)) // write rev'd assets to build dir
		.pipe(plugins.rev.manifest(manifestFilename, {
			base: 'public/',
			merge: true
		}))
		.pipe(gulp.dest(basePaths.dest)) // write manifest to public dir
		.pipe(livereload());
});

gulp.task('measureMobilePerformance', function() {
	return psi(siteUrl, {
		// key: key
		nokey: 'true',
		strategy: 'mobile',
	}, function(err, data) {
		console.log(siteUrl);
		console.log("score: " + data.score);
		console.log(data.pageStats);
	});
});

gulp.task('measureDesktopPerformance', function() {
	return psi(siteUrl, {
		nokey: 'true',
		// key: key,
		strategy: 'desktop',
	}, function(err, data) {
		console.log(siteUrl);
		console.log("score: " + data.score);
		console.log(data.pageStats);
	});
});

//Build sprite sheets
gulp.task('sprite', function () {
	var spriteData = gulp.src(paths.images.src + 'icons/*.png').pipe(plugins.spritesmith({
		imgName: 'gousto_sprite.png',
		cssName: 'gousto_sprite.css'
	}));
	return spriteData.pipe(gulp.dest(paths.images.src));
});

//Build SVG sprite sheets
gulp.task('svgstore', function () {
	var revAll = new RevAll();
	return gulp
		.src(paths.images.src + 'sprite/**/*.svg')
		.pipe(plugins.svgmin(function (file) {
			var prefix = path.basename(file.relative, path.extname(file.relative));
			return {
				plugins: [{
					cleanupIDs: {
						prefix: prefix + '-',
						minify: true
					}
				}]
			};
		}))
		.pipe(plugins.svgstore({ inlineSvg: true }))


		.pipe(revAll.revision({}))
		.pipe(gulp.dest(paths.images.dest)) // write rev'd assets to build dir
		.pipe(plugins.rev.manifest(manifestFilename, {
			base: 'public/',
			merge: true
		}))
		.pipe(gulp.dest(basePaths.dest)); // write manifest to public dir
});

/**
 * Rebuild the entire public/build directory.
 *
 * This function should only be necessary once, or to obliterate the build
 * directory and start again. Note: rebuild uses the @function flush,
 * which is destructive.
 *
 * @example usage
 * // gulp rebuild
 */

gulp.task('rebuild', function(callback) {
	runSequence('flush', ['styles', 'scripts', 'images'],
		callback);
});

/**
 * Deploy to production environment.
 *
 * Similar to rebuild @function, in that it obliterates and re-prepares the
 * public/build directory, but also prepares the assets for use in
 * production environment. This function will most liklely only ever be
 * used by a Puppet script or equivalent.p
 */
gulp.task('deploy', ['flush', 'styles', 'scripts', 'smushit', 'rev', 'gz']);


/**
 * Obliterate the built asset directories
 *
 * The flush functions are destructive, and will recursively remove files
 * from the relevant directories
 *
 * @example usage
 * // gulp flush
 */
gulp.task('flush-scripts', function(cb) {
	rimraf(paths.scripts.dest, cb);
});
gulp.task('flush-styles', function(cb) {
	rimraf(paths.styles.dest, cb);
});
gulp.task('flush-images', function(cb) {
	rimraf(paths.images.dest, cb);
});
gulp.task('flush-fonts', function(cb) {
	rimraf(paths.fonts.dest, cb);
});
gulp.task('flush-gz', function(cb) {
	rimraf(basePaths.dest + '/gz', cb);
});
gulp.task('flush-manifest', function(cb) {
	rimraf(manifestFilename, cb);
});
gulp.task('flush', function(cb) {
	runSequence('flush-manifest', 'flush-scripts', 'flush-styles', 'flush-images', 'flush-fonts', 'flush-gz', cb);
});

// rerun tasks when a file changes
gulp.task('upload', function(cb) {
	if (isProduction) {
		runSequence('aws', 'awsFonts');
	} else {
		console.log("Exiting - Assets can only be uploaded running in production mode");
		return;
	}
});

gulp.task('die');

gulp.task('assetbuild', function() {
	runSequence('scripts', 'styles', 'fonts', 'gzipscripts', 'gzipstyles', 'gzipfonts', 'syncSourceMaps');
	runSequence('images', 'svgstore');
	runSequence('fonts');
	return;
});

gulp.task('default', function(cb) {
	runSequence('flush', 'assetbuild', 'reactScripts', function() {
		if (!isProduction) {
			console.log("**** DEV MODE. WATCHING FOR FILE CHANGES ****");
			gulp.run('watch');
		} else {
			return;
		}
	});
});

gulp.task('once', function(cb) {
	runSequence('flush', 'assetbuild');
});

gulp.task('watch', function() {

	livereload.listen(liveReloadOptions);

	gulp.watch(appFiles.scripts, ['eslint']);
	gulp.watch([paths.scripts.orderPath, appFiles.scripts], ['scripts', 'gzipscripts']);
	gulp.watch([paths.styles.orderPath, appFiles.styles], ['styles', 'gzipstyles']);
	gulp.watch(appFiles.images, ['images']);
	gulp.watch(appFiles.fonts, ['fonts', 'gzipfonts']);
});


var browserify = require('browserify');
//var reactify = require ('reactify');
var babelify = require('babelify');
var streamify = require('gulp-streamify');
var source = require('vinyl-source-stream');
var watchify = require('watchify');
var env = require('gulp-env');
var rename = require('gulp-rename');

if (isProduction) {
	env({
		vars:{
			NODE_ENV: "production"
		}
	});
}

var reactPath = {};
reactPath.ENTRY_POINT = './app/assets/js/GoustoMarket.js';
reactPath.MINIFIED_OUT = 'bundle.min.js';
reactPath.DEST_BUILD = 'public/js';
reactPath.DEST_SRC = './app/assets/';
reactPath.TEMPLATES = './app/views/*';
reactPath.OUT = 'bundle.js';

gulp.task('react', function() {
	gulp.watch(reactPath.DEST_SRC + 'js', ['build']);
});


gulp.task('build', function(){
	var revAll = new RevAll();
	browserify({
		entries: [reactPath.ENTRY_POINT],
		transform: [babelify],
	})
	.bundle()
	.pipe(source(reactPath.MINIFIED_OUT))
	.pipe(streamify(plugins.uglify(reactPath.MINIFIED_OUT)))
	.pipe(streamify(revAll.revision()))
	.pipe(gulp.dest(paths.scripts.dest)) // write rev'd assets to build dir
	.pipe(plugins.rev.manifest(manifestFilename, {
		base: reactPath.DEST_BUILD,
		merge: true
	}))
	.pipe(gulp.dest(paths.scripts.dest))
	.pipe(gulp.dest(reactPath.DEST_BUILD));
});

function scripts(watch) {
	//move config
	var reactConfigPath = './app/assets/js/config/';
	var reactConfigSrc = reactConfigPath + 'dev.js';
	if (isProduction) {
		reactConfigSrc = reactConfigPath + 'prod.js';
	}

	gulp.src(reactConfigSrc)
		.pipe(plugins.replace(/\[product_service_domain\]/g, productServiceDomain))
		.pipe(rename('env.js'))
		.pipe(gulp.dest(reactConfigPath));

	var bundler, rebundle;
	bundler = browserify(reactPath.ENTRY_POINT, {
		basedir: __dirname,
		debug: !isProduction,
		transform: [babelify],
		cache: {}, // required for watchify
		packageCache: {}, // required for watchify
		fullPath: watch // required to be true only for watchify
	});
	if (watch) {
		bundler = watchify(bundler)
	}

	rebundle = function() {
		var stream = bundler.bundle();
		stream.on('error', function(err){ console.log("err: " + err); });
		stream = stream.pipe(source(reactPath.MINIFIED_OUT));
		return stream.pipe(gulp.dest(reactPath.DEST_BUILD));
	};

	bundler.on('update', rebundle);
	if (!watch) {
		gulp.run('build');
		return false;
	}
	return rebundle();
}

gulp.task('reactScripts', function() {
	return scripts(!isProduction);
});
